#!/bin/zsh

################################################################################
#                                                                              #
#   MIT License                                                                #
#                                                                              #
#   Copyright (c) 2024 wycomco                                                 #
#                                                                              #
#   Permission is hereby granted, free of charge, to any person obtaining a    #
#   copy of this software and associated documentation files (the "Software"), #
#   to deal in the Software without restriction, including without limitation  #
#   the rights to use, copy, modify, merge, publish, distribute, sublicense,   #
#   and/or sell copies of the Software, and to permit persons to whom the      #
#   Software is furnished to do so, subject to the following conditions:       #
#                                                                              #
#   The above copyright notice and this permission notice shall be included    #
#   in all copies or substantial portions of the Software.                     #
#                                                                              #
#   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS    #
#   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF                 #
#   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.     #
#   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY       #
#   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,       #
#   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE          #
#   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                     #
#                                                                              #
################################################################################


################################################################################
# Functions                                                                    #
################################################################################

check_daemon() {
    DaemonHourPlist=$(PlistBuddy -c "print :StartCalendarInterval:Hour" $DaemonPath)
    DaemonMinutePlist=$(PlistBuddy -c "print :StartCalendarInterval:Minute" $DaemonPath)
    # Remove leading zeros if present
    DaemonHourPlist=${DaemonHourPlist#0}
    DaemonMinutePlist=${DaemonMinutePlist#0}
    if [[ $DaemonHourPlist -ne $DaemonHour ]]; then
        PlistBuddy -c "Set :StartCalendarInterval:Hour $DaemonHour" $DaemonPath
    fi
    if [[ $DaemonMinutePlist -ne $DaemonMinute ]]; then
        PlistBuddy -c "Set :StartCalendarInterval:Minute $DaemonMinute" $DaemonPath
    fi
}

check_space() {
    local boot_disk boot_space repo_disk repo_space total_required_space
    boot_disk=$(df -P "$Base_Path" | awk 'NR==2{print $1}')
    boot_space=$(df -k "$boot_disk" | awk 'NR==2{print int($4 / 1024 / 1024)}')
    repo_disk=$(df -P "$RepoPath" | awk 'NR==2{print $1}')
    repo_space=$(df -k "$RepoPath" | awk 'NR==2{print int($4 / 1024 / 1024)}')

    if [[ "$repo_disk" == "$boot_disk" ]]; then
        total_required_space=$((repo_required + diskspace_required))
        if (( boot_space < total_required_space )); then
            echo_err "Less than $total_required_space GB on the boot disk holding both repo and boot volume. Please provide more space."
            exit 1
        fi
    fi

    if (( repo_space < repo_required )); then
        echo_err "Less than $repo_required GB space on repo left. Please provide more space."
        exit 1
    fi

    if (( boot_space < diskspace_required )); then
        echo_err "Less than $diskspace_required GB space on boot volume left. Please provide more space."
        exit 1
    fi
}

cleanup() {
    rm -rf "$Base_Path/Install macOS $os_nice.app"
    mv "$LogPath"/current_state_"$os_major".txt "$LogPath"/previous_state_"$os_major".txt
    echo "Last update for macOS "$os_nice" ran on $(date)" >> "$LogPath"/changelog.txt
}

deploy_macos() {
    sudo -u "$RepoOwner" munkiimport -n --installer-type copy_from_dmg --name="$deploy_name" \
    -c "$munki_catalog" --category="$munki_category" --developer=Apple --displayname="macOS $os_nice preparation"  \
    --description="Downloads macOS $os_nice installer $fqos and places it in the Applications directory for installation at a later time."  \
    --icon="${munki_name}_$os_munki.png" --minimum_munki_version="$munki_mini" \
    --maximum_os_version="$os_maxi" --minimum_os_version="$os_mini" \
    --postinstall_script="$Template"/postinstall_script_installer \
    --subdirectory="$munki_path" --unattended_install --unattended_uninstall \
    --pkgvers="$fqos" "$pkgsdir/$munki_name-$fqos.dmg"
    if [[ $localization == "yes" ]]; then
        localized=$(awk '/<key>maximum_os_version<\/key>/ {print NR-1; exit}' "$pkgsinfodir/$deploy_name-$fqos.plist")
        head -n "$localized" "$pkgsinfodir/$deploy_name-$fqos.plist" > "$pkgsinfodir/$deploy_name-$fqos.plist.tmp"
        cat "$Base_Path/usr/localized_deploy.txt" >> "$pkgsinfodir/$deploy_name-$fqos.plist.tmp"
        awk -v localized="${localized}" 'NR > localized' "$pkgsinfodir/$deploy_name-$fqos.plist" >> "$pkgsinfodir/$deploy_name-$fqos.plist.tmp"
        sed "s/%version%/$fqos/g" "$pkgsinfodir/$deploy_name-$fqos.plist.tmp" > "$pkgsinfodir/$deploy_name-$fqos.plist"
    fi
    install_condition=$(grep '<string>board_id IN {' "$pkgsinfodir/arm64/$munki_name-$fqos.plist")
    install_hash=$(awk '/<key>installer_item_hash<\/key>/ {print NR-1; exit}' "$pkgsinfodir/$deploy_name-$fqos.plist")
    head -n "$install_hash" "$pkgsinfodir/$deploy_name-$fqos.plist" > "$pkgsinfodir/$deploy_name-$fqos.plist.tmp"
    echo '	<key>installable_condition</key>' >> "$pkgsinfodir/$deploy_name-$fqos.plist.tmp"
    cat <<EOF >> "$pkgsinfodir/$deploy_name-$fqos.plist.tmp"
$(echo "$install_condition")
EOF
    awk -v install_hash="${install_hash}" 'NR > install_hash' "$pkgsinfodir/$deploy_name-$fqos.plist" >> "$pkgsinfodir/$deploy_name-$fqos.plist.tmp"
    sed "s/%os_nice%/$os_nice/g" "$pkgsinfodir/$deploy_name-$fqos.plist.tmp" > "$pkgsinfodir/$deploy_name-$fqos.plist"
    rm "$pkgsinfodir/$deploy_name-$fqos.plist.tmp"
}

download_macos() {
    if [[ -t 1 ]]; then
        # Reduce output, but output progress of single steps for interactive run
        mist download installer $os_major application --application-name "Install macOS $os_nice.app" --force | grep '\[ [1-9][0-9]* \/ [1-9][0-9]* \]'
    else
        # If invoked by launchd, only print error messages to StandardErrorPath
        mist download installer $os_major application --application-name "Install macOS $os_nice.app" --force > /dev/null 2>> /var/log/misty_error.log
    fi
}

echo_err() {
    local date_time
    date_time=$(date +'%Y-%m-%d %H:%M')
    local message="$@"
    # Check if running as LaunchDaemon
    if [[ ! -t 1 ]]; then
        # Print to stderr with timestamp
        echo "${date_time}  ${message}" >&2
    else
        echo "${message}"
    fi
}

echo_std() {
    local date_time
    date_time=$(date +'%Y-%m-%d %H:%M')
    local message="$@"
    # Check if running as LaunchDaemon
    if [[ ! -t 1 ]]; then
        # Print to stdout with timestamp
        echo "${date_time}  ${message}"
    else
        echo "${message}"
    fi
}

extract_macos_version() {
    sed -n 's/.*macOS '"$1"'[^0-9]*\([0-9.]*\).*/\1/p' "$2" | tr -d '[:space:]'
}

extract_time_input() {
    DaemonHour=$(echo $time_input | cut -d: -f1)
    DaemonMinute=$(echo $time_input | cut -d: -f2)
    DaemonHour=${DaemonHour#0}
    DaemonMinute=${DaemonMinute#0}
}

munkiimport_stage_os() {
    munkiimport -n --installer-type stage_os_installer --name="$munki_name" \
    -c "$munki_catalog" --category="$munki_category" --developer=Apple \
    --displayname="macOS $os_nice" --description="Downloads macOS $os_nice $fqos" \
    --icon="${munki_name}_$os_munki.png" --minimum_munki_version="$munki_mini" \
    --maximum_os_version="$os_maxi" --minimum_os_version="$os_mini" \
    --arch=arm64 --RestartAction=RequireRestart --repo-url=file://"$RepoPath" \
    --subdirectory="$munki_path" --unattended_install --unattended_uninstall \
    --pkgvers="$fqos" "$Base_Path/Install macOS $os_nice.app"
    # File name and plist content manipulations
    mv "$pkgsdir/Install macOS $os_nice-$fqos.dmg" "$pkgsdir/$munki_name-$fqos.dmg"
    mv "$pkgsinfodir/$munki_name-$fqos-arm64" "$pkgsinfodir/arm64/$munki_name-$fqos.plist"
    sed -i.tmp \
        -e "s/Installs macOS $os_nice, version $fqos/Installs macOS $os_nice $fqos/" \
        -e 's/installable_condition_disabled/installable_condition/g' \
        -e "s|$munki_path/Install macOS $os_nice-$fqos.dmg|$munki_path/$munki_name-$fqos.dmg|g" \
        "$pkgsinfodir/arm64/$munki_name-$fqos.plist"
    if [[ $localization == "yes" ]]; then
        localized=$(awk '/<key>maximum_os_version<\/key>/ {print NR-1; exit}' "$pkgsinfodir/arm64/$munki_name-$fqos.plist")
        head -n "$localized" "$pkgsinfodir/arm64/$munki_name-$fqos.plist" > "$pkgsinfodir/arm64/$munki_name-$fqos.plist.tmp"
        cat "$Base_Path"/usr/localized_stage_os.txt >> "$pkgsinfodir/arm64/$munki_name-$fqos.plist.tmp"
        awk -v localized="${localized}" 'NR > localized' "$pkgsinfodir/arm64/$munki_name-$fqos.plist" >> "$pkgsinfodir/arm64/$munki_name-$fqos.plist.tmp"
        sed "s/%version%/$fqos/g" "$pkgsinfodir/arm64/$munki_name-$fqos.plist.tmp" > "$pkgsinfodir/arm64/$munki_name-$fqos.plist"
    fi
    pre_inserts=$(awk '/<key>supported_architectures<\/key>/ {print NR-1; exit}' "$pkgsinfodir/arm64/$munki_name-$fqos.plist")
    head -n "$pre_inserts" "$pkgsinfodir/arm64/$munki_name-$fqos.plist" > "$pkgsinfodir/arm64/$munki_name-$fqos.plist.tmp"
    cat "$Template/pre_inserts_arm64" >> "$pkgsinfodir/arm64/$munki_name-$fqos.plist.tmp"
    awk -v pre_inserts="${pre_inserts}" 'NR > pre_inserts' "$pkgsinfodir/arm64/$munki_name-$fqos.plist" >> "$pkgsinfodir/arm64/$munki_name-$fqos.plist.tmp"
    mv "$pkgsinfodir/arm64/$munki_name-$fqos.plist.tmp" "$pkgsinfodir/arm64/$munki_name-$fqos.plist"
    chown "$Repo_uid_gid" "$pkgsdir/$munki_name-$fqos.dmg"
    chown -R "$Repo_uid_gid" "$pkgsinfodir"/arm64
}

munkiimport_startos() {
    munkiimport -n --installer-type startosinstall --name="$munki_name" \
    -c "$munki_catalog" --category="$munki_category" --developer=Apple \
    --displayname="macOS $os_nice" --description="Installs macOS $os_nice $fqos" \
    --icon="${munki_name}_$os_munki.png" --minimum_munki_version=5.1.0 \
    --maximum_os_version="$os_maxi" --minimum_os_version="$os_mini" \
    --arch=x86_64 --RestartAction=RequireRestart --repo-url=file://"$RepoPath" \
    --subdirectory="$munki_path" \
    --pkgvers="$fqos" "$Base_Path/Install macOS $os_nice.app"
    rm "$pkgsdir/Install macOS $os_nice-$fqos.dmg"
    mv "$pkgsinfodir/$munki_name-$fqos-x86_64" "$pkgsinfodir/x86_64/$munki_name-$fqos.plist"
    # munkiimport creates different dmgs for stage_os and startos. We grab the required data from the stage_os plist to use its dmg
    installer_item_hash_stage_os=$(plutil -extract installer_item_hash raw -o - "$pkgsinfodir/arm64/$munki_name-$fqos.plist")
    installer_item_size_stage_os=$(plutil -extract installer_item_size raw -o - "$pkgsinfodir/arm64/$munki_name-$fqos.plist")
    plutil -replace installer_item_hash -string "$installer_item_hash_stage_os" "$pkgsinfodir/x86_64/$munki_name-$fqos.plist"
    plutil -replace installer_item_size -integer "$installer_item_size_stage_os" "$pkgsinfodir/x86_64/$munki_name-$fqos.plist"
    sed -i.tmp \
        -e "s/Installs macOS $os_nice, version $fqos/Installs macOS $os_nice $fqos/" \
        -e 's/installable_condition_disabled/installable_condition/g' \
        -e "s|$munki_path/Install macOS $os_nice-$fqos.dmg|$munki_path/$munki_name-$fqos.dmg|g" \
        "$pkgsinfodir/x86_64/$munki_name-$fqos.plist"
    if [[ $localization == "yes" ]]; then
        localized=$(awk '/<key>maximum_os_version<\/key>/ {print NR-1; exit}' "$pkgsinfodir/x86_64/$munki_name-$fqos.plist")
        head -n "$localized" "$pkgsinfodir/x86_64/$munki_name-$fqos.plist" > "$pkgsinfodir/x86_64/$munki_name-$fqos.plist.tmp"
        cat "$Base_Path/usr/localized_startos.txt" >> "$pkgsinfodir/x86_64/$munki_name-$fqos.plist.tmp"
        awk -v localized="${localized}" 'NR > localized' "$pkgsinfodir/x86_64/$munki_name-$fqos.plist" >> "$pkgsinfodir/x86_64/$munki_name-$fqos.plist.tmp"
        sed "s/%version%/$fqos/g" "$pkgsinfodir/x86_64/$munki_name-$fqos.plist.tmp" > "$pkgsinfodir/x86_64/$munki_name-$fqos.plist"
    fi
    pre_inserts=$(awk '/<key>supported_architectures<\/key>/ {print NR-1; exit}' "$pkgsinfodir/x86_64/$munki_name-$fqos.plist")
    head -n "$pre_inserts" "$pkgsinfodir/x86_64/$munki_name-$fqos.plist" > "$pkgsinfodir/x86_64/$munki_name-$fqos.plist.tmp"
    cat "$Template/pre_inserts_x86_64" >> "$pkgsinfodir/x86_64/$munki_name-$fqos.plist.tmp"
    awk -v pre_inserts="${pre_inserts}" 'NR > pre_inserts' "$pkgsinfodir/x86_64/$munki_name-$fqos.plist" >> "$pkgsinfodir/x86_64/$munki_name-$fqos.plist.tmp"
    mv "$pkgsinfodir/x86_64/$munki_name-$fqos.plist.tmp" "$pkgsinfodir/x86_64/$munki_name-$fqos.plist"
    chown -R "$Repo_uid_gid" "$pkgsinfodir/x86_64"
}

preloader_arm() {
    sudo -u "$RepoOwner" munkiimport -n --installer-type copy_from_dmg --name="$munki_name"_arm \
    -c "$munki_catalog" --category="$munki_category" --developer=Apple \
    --displayname="macOS $os_nice preparation"  --description="Provisions macOS $os_nice $fqos for installation"  \
    --icon="${munki_name}_$os_munki.png" --minimum_munki_version="$munki_mini" \
    --maximum_os_version="$os_maxi" --minimum_os_version="$os_mini" \
    --postinstall_script="$Template/postinstall_script_installer" \
    --arch=arm64 \
    --subdirectory="$munki_path" --unattended_install --unattended_uninstall \
    --pkgvers="$fqos" "$pkgsdir/$munki_name-$fqos.dmg"
    mv "$pkgsinfodir/${munki_name}_arm-$fqos-arm64.plist" "$pkgsinfodir/arm64/${munki_name}_arm-$fqos.plist"
    # Retrieve installable_condition from munkiimport_macos and fill in
    if [[ $localization == "yes" ]]; then
        localized=$(awk '/<key>maximum_os_version<\/key>/ {print NR-1; exit}' "$pkgsinfodir/arm64/${munki_name}_arm-$fqos.plist")
        head -n "$localized" "$pkgsinfodir/arm64/${munki_name}_arm-$fqos.plist" > "$pkgsinfodir/arm64/${munki_name}_arm-$fqos.plist.tmp"
        cat "$Base_Path/usr/localized_arm.txt" >> "$pkgsinfodir/arm64/${munki_name}_arm-$fqos.plist.tmp"
        awk -v localized="${localized}" 'NR > localized' "$pkgsinfodir/arm64/${munki_name}_arm-$fqos.plist" >> "$pkgsinfodir/arm64/${munki_name}_arm-$fqos.plist.tmp"
        sed "s/%version%/$fqos/g" "$pkgsinfodir/arm64/${munki_name}_arm-$fqos.plist.tmp" > "$pkgsinfodir/arm64/${munki_name}_arm-$fqos.plist"
    fi
    install_condition=$(grep '<string>board_id IN {' "$pkgsinfodir/arm64/$munki_name-$fqos.plist")
    install_hash=$(awk '/<key>installer_item_hash<\/key>/ {print NR-1; exit}' "$pkgsinfodir/arm64/${munki_name}_arm-$fqos.plist")
    head -n "$install_hash" "$pkgsinfodir/arm64/${munki_name}_arm-$fqos.plist" > "$pkgsinfodir/arm64/${munki_name}_arm-$fqos.plist.tmp"
    echo '	<key>installable_condition</key>' >> "$pkgsinfodir/arm64/${munki_name}_arm-$fqos.plist.tmp"
    cat <<EOF >> "$pkgsinfodir/arm64/${munki_name}_arm-$fqos.plist.tmp"
$(echo "$install_condition")
EOF
    awk -v install_hash="${install_hash}" 'NR > install_hash' "$pkgsinfodir/arm64/${munki_name}_arm-$fqos.plist" >> "$pkgsinfodir/arm64/${munki_name}_arm-$fqos.plist.tmp"
    sed "s/%os_nice%/$os_nice/g" "$pkgsinfodir/arm64/${munki_name}_arm-$fqos.plist.tmp" > "$pkgsinfodir/arm64/${munki_name}_arm-$fqos.plist"
    rm "$pkgsinfodir/arm64/${munki_name}_arm-$fqos.plist.tmp"
}

repo_stuff () {
    check_space
    rm_previous_files
    echo_std "Downloading installer for macOS $fqos"
    download_macos
    munkiimport_stage_os
    preloader_arm
    deploy_macos
    munkiimport_startos
    cleanup
}

rm_color_codes() {
    sed 's/\x1B\[[0-9;]\{1,\}[A-Za-z]//g' "$1"
}

rm_previous_files() {
    setopt nullglob
    if ! ls -1 "$pkgsdir"/"$munki_name"-"$os_major"* >/dev/null 2>&1; then
        echo_std "No files matching $munki_name version $os_major found. Not removing any files."
        return
    fi

    local fqos_retired=()
    local initial_versions=0
    local files_deleted=false
    
    for file in "$pkgsdir"/"$munki_name"-*; do
        # Extract the version number from the filename
        version=$(basename "$file" | sed "s/${munki_name}-\(.*\)\.dmg/\1/")
        # Remove part before the version number
        major=$(echo "$version" | cut -d. -f1)
        # Check if major version matches os_major
        if [[ $major == $os_major ]]; then
            # Remove .dmg from the filename
            filename=$(basename "$file" | sed "s/${munki_name}-//" | sed 's/\.dmg$//')
            # Add the filename to fqos_retired array
            fqos_retired+=("$filename")
        fi
    done
    
    initial_versions=${#fqos_retired[@]} # Count initial versions found

    # Loop through unique major versions
    for major_version in $(echo "${fqos_retired[@]}" | cut -d. -f1 | sort -u); do
        # Filter files based on major version
        major_files=($(echo "${fqos_retired[@]}" | grep "^${major_version}"))
        # Sort files based on minor and patch version numbers in descending order
        major_files_sorted=($(printf '%s\n' "${major_files[@]}" | sort -rV))
        # Keep only the first element (highest minor and patch version)
        major_files_sorted=("${(@)major_files_sorted:1}")    
        # Loop through major_files_sorted array and remove corresponding files
        for file in "${major_files_sorted[@]}"; do
            rm -f "${pkgsdir}"/*"${file}".dmg
            rm -f "${pkgsinfodir}"/*"${file}".plist
            rm -f "${pkgsinfodir}"/arm64/*"${file}".plist
            rm -f "${pkgsinfodir}"/x86_64/*"${file}".plist
            echo_std "Removed version(s) ${file} from pkgs and pkgsinfo directories"
            files_deleted=true
        done
    done

    # Check if only one version was found or if no files were deleted
    if [ "$initial_versions" -eq 1 ] || [ "$files_deleted" = false ]; then
        echo_std "Only one previous version of $munki_name version $os_major found. Not removing any files."
    fi
}

################################################################################
# Global definitions, checks                                                   #
################################################################################

export PATH="/usr/bin:/usr/local/bin:/usr/local/munki:/usr/libexec:$PATH"

repo_required=28 # Size required on repo for arm64 and x86_64 installer in GB, needed during creation
diskspace_required=30 # Size required on boot disk for installer and cache in GB
Base_Path="/Users/Shared/Mist"
LogPath="$Base_Path/Logs"
Template="$Base_Path/skel"
DaemonPath="/Library/LaunchDaemons/de.wycomco.misty.plist"

if [[ $EUID -ne 0 ]]; then
   echo_err "Please run the script as root." 
   exit 1
fi
mist_check=$(which mist)
if [ $? -ne 0 ]; then
    echo_err "Error: mist not found. Please install mist-cli or put it into the PATH."
    exit 1
fi
munkiimport_check=$(which munkiimport)
if [ $? -ne 0 ]; then
    echo_err "Error: munkiimport not found. Please check your munki installation."
    exit 1
fi
if [[ ! -d "$LogPath" ]]; then
    mkdir -p "$LogPath"
fi
if [[ ! -d "$Template" || ! $(ls -A "$Template") ]]; then
    echo_err "Error: The directory \"$Template\" either does not exist or is empty. Please reinstall misty."
    exit 1
fi

################################################################################
# First run                                                                    #
################################################################################

if [[ ! -d "$Base_Path/usr" ]]; then
    mkdir -p "$Base_Path/usr"
    chmod 777 "$Base_Path/usr"
fi
if [[ ! -f "$Base_Path/usr/config.txt" ]]; then
    currentUser=$(echo "show State:/Users/ConsoleUser" | scutil | awk '/Name :/ { print $3 }')
    cp "$Template/config.txt" "$Base_Path/usr"
    while true; do
        echo
        echo "Please enter the time when the script should start in 24 hour format (HH:MM): "
        read time_input
        extract_time_input
        PlistBuddy -c "Set :StartCalendarInterval:Hour $DaemonHour" $DaemonPath
        PlistBuddy -c "Set :StartCalendarInterval:Minute $DaemonMinute" $DaemonPath
        echo "# Start of script in the LaunchDaemon" >> "$Base_Path/usr/config.txt"
        echo "time_input=\"$time_input\"" >> "$Base_Path/usr/config.txt"
        if ! launchctl list | grep -q "de.wycomco.misty"; then
            # Re-enable when LaunchDaemon can access smb shares
            #launchctl load $DaemonPath
        fi
        echo "Do you want to use localized strings in the resulting plists? (y/n)"
        read yn
        case $yn in
            [Yy]* )
            cp "$Template/localized_arm.txt" "$Template/localized_deploy.txt" "$Template/localized_stage_os.txt" "$Template/localized_startos.txt" "$Base_Path/usr"
            sed -i '' 's/localization="no"/localization="yes"/g' "$Base_Path"/usr/config.txt
            echo "Please adjust the file config.txt and any localized_*.txt files in $Base_Path/usr to your needs now."
            chmod 666 "$Base_Path/usr/*.txt"
            echo "A finder window will open in 5 seconds."
            sleep 5
            su -l "$currentUser" -c "open $Base_Path/usr"
            exit 0 ;;
            [Nn]* )
            echo "Please adjust the file $Base_Path/usr/config.txt to your needs now."
            chmod 666 "$Base_Path/usr/*.txt"
            echo "A finder window will open in 5 seconds."
            sleep 5
            su -l "$currentUser" -c "open $Base_Path/usr"
            exit 0;;
            * ) echo "Please answer using [y] or [n].";;
        esac
    done
fi

################################################################################
# Import config, more definitions                                              #
################################################################################

# Load definitions from config file in /Users/Shared/Mist/usr
source "$Base_Path"/usr/config.txt
echo "RepoPath: $RepoPath" > /dev/null
echo "munki_path: $munki_path" > /dev/null
echo "munki_name: $munki_name" > /dev/null
echo "deploy_name: $deploy_name" > /dev/null
echo "munki_catalog_12: $munki_catalog_12" > /dev/null
echo "munki_catalog_13: $munki_catalog_13" > /dev/null
echo "munki_catalog_14: $munki_catalog_14" > /dev/null
echo "munki_category: $munki_category" > /dev/null
echo "time_input: $time_input" > /dev/null
echo "localization: $localization" > /dev/null

extract_time_input

Repo_uid_gid=$(stat -f "%Su:%Sg" "$RepoPath")
RepoOwner=$(stat -f "%Su" "$RepoPath")
pkgsdir="$RepoPath/pkgs/$munki_path"
pkgsinfodir="$RepoPath/pkgsinfo/$munki_path"

################################################################################
# Check environment                                                            #
################################################################################

if [[ ! -d "$RepoPath" ]]; then
    echo_err "Error: Repository \"$RepoPath\" not accessible, please check."
    exit 1
fi
if [[ ! -d "$pkgsinfodir"/arm64 ]]; then
    sudo -u "$RepoOwner" mkdir -p "$pkgsinfodir/arm64"
    chmod 755 "$pkgsinfodir"/arm64
    chown "$Repo_uid_gid" "$pkgsinfodir/arm64"
fi
if [[ ! -d "$pkgsinfodir"/x86_64 ]]; then
    sudo -u "$RepoOwner" mkdir -p "$pkgsinfodir/x86_64"
    chmod 755 "$pkgsinfodir/x86_64"
    chown "$Repo_uid_gid" "$pkgsinfodir/x86_64"
fi
check_daemon

################################################################################
# Update checks                                                                #
################################################################################

# We want to check each major version seperately
mist list installer 14 --latest | grep GB > "$LogPath/tmp_state_14.txt"
mist list installer 13 --latest | grep GB > "$LogPath/tmp_state_13.txt"
mist list installer 12 --latest | grep GB > "$LogPath/tmp_state_12.txt"

# Remove color codes resulting from grep and clean up
rm_color_codes "$LogPath/tmp_state_14.txt" > "$LogPath/current_state_14.txt"
rm_color_codes "$LogPath/tmp_state_13.txt" > "$LogPath/current_state_13.txt"
rm_color_codes "$LogPath/tmp_state_12.txt" > "$LogPath/current_state_12.txt"
/bin/rm -f "$LogPath/tmp_state_*.txt"

# Compare the content with the previous state if present, ignoring last two columns (date and compatibliity)
if [ -f "$LogPath/previous_state_14.txt" ]; then
    if ! awk '{ for(i=2;i<=NF-4;i++) printf "%s ", $i; print "" }' "$LogPath/current_state_14.txt" | cmp -s - <(awk '{ for(i=2;i<=NF-4;i++) printf "%s ", $i; print "" }' "$LogPath/previous_state_14.txt"); then
        macos_14=$(extract_macos_version Sonoma "$LogPath/current_state_14.txt")
    fi
else
    macos_14=$(extract_macos_version Sonoma "$LogPath/current_state_14.txt")
fi

if [ -f "$LogPath/previous_state_13.txt" ]; then
    if ! awk '{ for(i=2;i<=NF-4;i++) printf "%s ", $i; print "" }' "$LogPath/current_state_13.txt" | cmp -s - <(awk '{ for(i=2;i<=NF-4;i++) printf "%s ", $i; print "" }' "$LogPath/previous_state_13.txt"); then
        macos_13=$(extract_macos_version Ventura "$LogPath/current_state_13.txt")
    fi
else
    macos_13=$(extract_macos_version Ventura "$LogPath/current_state_13.txt")
fi

if [ -f "$LogPath/previous_state_12.txt" ]; then
    if ! awk '{ for(i=2;i<=NF-4;i++) printf "%s ", $i; print "" }' "$LogPath/current_state_12.txt" | cmp -s - <(awk '{ for(i=2;i<=NF-4;i++) printf "%s ", $i; print "" }' "$LogPath/previous_state_12.txt"); then
        macos_12=$(extract_macos_version Monterey "$LogPath/current_state_12.txt")
    fi
else
    macos_12=$(extract_macos_version Monterey "$LogPath/current_state_12.txt")
fi

################################################################################
# Update routines                                                              #
################################################################################

# Execute loops only if version has changed
if [ -n "$macos_14" ]; then
    fqos=$macos_14
    munki_catalog=$munki_catalog_14
    munki_mini=6.3
    os_major="14"
    os_maxi="13.99"
    os_mini="10.13"
    os_munki="sonoma"
    os_nice="Sonoma"
    repo_stuff
fi
if [ -n "$macos_13" ]; then
    fqos=$macos_13
    munki_catalog=$munki_catalog_13
    munki_mini=6.0.1
    os_major="13"
    os_maxi="12.99"
    os_mini="10.12"
    os_munki="ventura"
    os_nice="Ventura"
    repo_stuff
fi
if [ -n "$macos_12" ]; then
    fqos=$macos_12
    munki_catalog=$munki_catalog_12
    os_major="12"
    os_maxi="11.99"
    os_mini="10.9"
    os_munki="monterey"
    os_nice="Monterey"
    repo_stuff
fi

################################################################################
# Postinstall, makecatalogs                                                    #
################################################################################

# Check if any new package(s) were created
if [[ ( -n "$macos_12" || -n "$macos_13" || -n "$macos_14" ) ]]; then
    if [[ -f "$Base_Path/usr/postinstall.sh" ]]; then
        "$Base_Path/usr/postinstall.sh"
    fi
    makecatalogs "$RepoPath" | grep 'warning'
fi

echo_std "Finished misty run."

exit 0
