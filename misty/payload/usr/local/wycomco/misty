#!/bin/zsh -e

#   This script checks for availability of new releases of macOS, starting
#   from macOS Monterey, using mist-cli (https://github.com/ninxsoft/mist-cli)
#   and imports into munki.
#
#   Copyright 2024 by wycomco.
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <https://www.gnu.org/licenses/>.


##################################
# Global definitions, first run  #
##################################

export PATH="/usr/bin:/usr/local/bin:/usr/local/munki:$PATH"

repo_required=14 # Size required on repo for single installer in GB
diskspace_required=30 # Size required on boot disk for single installer in GB
Base_Path="/Users/Shared/Mist"
LogPath="$Base_Path/Logs"
Template="$Base_Path/skel"

if [[ ! -d "$Base_Path/usr" ]]; then
    mkdir -p "$Base_Path/usr"
    chmod 777 "$Base_Path/usr"
fi
if [[ ! -f "$Base_Path/usr/override.txt" ]]; then
    currentUser=$(echo "show State:/Users/ConsoleUser" | scutil | awk '/Name :/ { print $3 }')
    cp "$Template/override.txt" $Base_Path/usr
    while true; do
        echo
        echo "Do you want to use localized strings in the resulting plists? (y/n)"
        read yn
        case $yn in
            [Yy]* )
            cp "$Template"/localized_arm.txt "$Template"/localized_deploy.txt "$Template"/localized_stage_os.txt "$Template"/localized_startos.txt "$Base_Path"/usr
            sed -i '' 's/localization="no"/localization="yes"/g' "$Base_Path"/usr/override.txt
            echo "Please adjust the file override.txt and any localized_*.txt files in $Base_Path/usr to your needs now."
            echo "A finder window will open in 5 seconds."
            sleep 5
            su -l "$currentUser" -c "open $Base_Path/usr"
            exit 0 ;;
            [Nn]* )
            echo "Please adjust the file $Base_Path/usr/override.txt to your needs now."
            echo "A finder window will open in 5 seconds."
            sleep 5
            su -l "$currentUser" -c "open $Base_Path/usr"
            exit 0;;
            * ) echo "Please answer using [y] or [n].";;
        esac
    done
    if ! launchctl list | grep -q "de.wycomco.misty"; then
        launchctl load /Library/LaunchDaemons/de.wycomco.misty.plist
    fi
fi

# Load definitions from config file in /Users/Shared/Mist/usr
source "$Base_Path"/usr/override.txt
echo "RepoPath: $RepoPath" > /dev/null
echo "munki_path: $munki_path" > /dev/null
echo "munki_name: $munki_name" > /dev/null
echo "deploy_name: $deploy_name" > /dev/null
echo "munki_catalog_12: $munki_catalog_12" > /dev/null
echo "munki_catalog_13: $munki_catalog_13" > /dev/null
echo "munki_catalog_14: $munki_catalog_14" > /dev/null
echo "munki_category: $munki_category" > /dev/null
echo "localization: $localization" > /dev/null

Repo_uid_gid=$(stat -f "%Su:%Sg" "$RepoPath")
RepoOwner=$(stat -f "%Su" "$RepoPath")
pkgsdir="$RepoPath/pkgs/$munki_path"
pkgsinfodir="$RepoPath/pkgsinfo/$munki_path"

##################################
# Check environment              #
##################################

mist_check=$(which mist)
if [ $? -ne 0 ]; then
    echo "Error: mist not found. Please install mist-cli or put it into the PATH." >&2
    exit 1
fi
munkiimport_check=$(which munkiimport)
if [ $? -ne 0 ]; then
    echo "Error: munkiimport not found. Please check your munki installation." >&2
    exit 1
fi
if [[ ! -d "$LogPath" ]]; then
    mkdir -p "$LogPath"
fi
if [[ ! -d "$Template" || ! $(ls -A "$Template") ]]; then
    echo "Error: The directory '$Template' either does not exist or is empty." >&2
    exit 1
fi
if [[ ! -d "$RepoPath" ]]; then
    echo "Error: Repository not accessible, please check." >&2
    exit 1
fi
if [[ $EUID -ne 0 ]]; then
   echo "Please run the script as root." 
   exit 1
fi
if [[ ! -d "$pkgsinfodir"/arm64 ]]; then
    mkdir -p "$pkgsinfodir"/arm64
    chmod 755 "$pkgsinfodir"/arm64
    chown "$Repo_uid_gid" "$pkgsinfodir"/arm64
fi
if [[ ! -d "$pkgsinfodir"/x86_64 ]]; then
    mkdir -p "$pkgsinfodir"/x86_64
    chmod 755 "$pkgsinfodir"/x86_64
    chown "$Repo_uid_gid" "$pkgsinfodir"/x86_64
fi

##################################
# Functions                      #
##################################

check_space() {
    local repo_space bootdisk_space repo_disk bootdisk_disk total_required_space
    repo_space=$(df -k "$RepoPath" | awk 'NR==2{print int($4 / 1024 / 1024)}')
    if (( repo_space < repo_required )); then
        echo "Less than $repo_required GB space on repo left. Please provide more space." >&2
        exit 1
    fi

    bootdisk=$(df -P "$Base_Path" | awk 'NR==2{print $1}')
    bootdisk_space=$(df -k "$bootdisk" | awk 'NR==2{print int($4 / 1024 / 1024)}')
    if (( bootdisk_space < diskspace_required )); then
        echo "Less than $diskspace_required GB space on boot volume left. Please provide more space." >&2
        exit 1
    fi

    repo_disk=$(df -P "$RepoPath" | awk 'NR==2{print $1}')
    bootdisk_disk=$(df -P "$Base_Path" | awk 'NR==2{print $1}')
    if [[ "$repo_disk" == "$bootdisk_disk" ]]; then
        total_required_space=$((repo_required + diskspace_required))
        if (( repo_space + bootdisk_space < total_required_space )); then
            echo "Less than $total_required_space GB on the boot disk holding both repo and boot volume. Please provide more space." >&2
            exit 1
        fi
    fi
}

rm_previous_files() {
    local fqos_retired=()
    
    for file in "$pkgsdir"/app_macos-*; do
        # Extract the version number from the filename
        version=$(basename "$file" | sed 's/app_macos-\(.*\)\.dmg/\1/')
        # Remove part before the version number
        major=$(echo "$version" | cut -d. -f1)
        # Check if major version matches os_major
        if [[ $major == $os_major ]]; then
            # Remove .dmg from the filename
            filename=$(basename "$file" | sed 's/app_macos-//' | sed 's/\.dmg$//')
            # Add the filename to fqos_retired array
            fqos_retired+=("$filename")
        fi
    done    
    # Loop through unique major versions
    for major_version in $(echo "${fqos_retired[@]}" | cut -d. -f1 | sort -u); do
        # Filter files based on major version
        major_files=($(echo "${fqos_retired[@]}" | grep "^${major_version}"))
        # Sort files based on minor and patch version numbers in descending order
        major_files_sorted=($(printf '%s\n' "${major_files[@]}" | sort -rV))
        # Keep only the first element (highest minor and patch version)
        major_files_sorted=("${(@)major_files_sorted:1}")    
        # Loop through major_files_sorted array and remove corresponding files
        for file in "${major_files_sorted[@]}"; do
            rm -f "${pkgsdir}"/*"${file}".dmg
            rm -f "${pkgsinfodir}"/*"${file}".plist
            rm -f "${pkgsinfodir}"/arm64/*"${file}".plist
            rm -f "${pkgsinfodir}"/x86_64/*"${file}".plist
            echo "Removed version(s) ${file} from pkgs and pkgsinfo directories"
        done
    done
}

rm_color_codes() {
    sed 's/\x1B\[[0-9;]\{1,\}[A-Za-z]//g' "$1"
}

extract_macos_version() {
    sed -n 's/.*macOS '"$1"'[^0-9]*\([0-9.]*\).*/\1/p' "$2" | tr -d '[:space:]'
}

download_macos() {
    if [[ -t 1 ]]; then
        # Reduce output, but output progress of single steps for interactive run
        mist download installer $os_major application --application-name "Install macOS $os_nice.app" --force | grep '\[ [1-9][0-9]* \/ [1-9][0-9]* \]'
    else
        # If invoked by launchd, only print error messages to StandardErrorPath
        mist download installer $os_major application --application-name "Install macOS $os_nice.app" --force > /dev/null 2>> /var/log/misty_error.log
    fi
}

munkiimport_stage_os() {
    munkiimport -n --installer-type stage_os_installer --name="$munki_name" \
    -c "$munki_catalog" --category="$munki_category" --developer=Apple \
    --displayname="macOS $os_nice" --description="Downloads macOS $os_nice $fqos" \
    --icon="$munki_name"_"$os_munki".png --minimum_munki_version=6.0.1 \
    --maximum_os_version="$os_maxi" --minimum_os_version="$os_mini" \
    --arch=arm64 --RestartAction=RequireRestart --repo-url=file://"$RepoPath" \
    --subdirectory="$munki_path" --unattended_install --unattended_uninstall \
    --pkgvers="$fqos" "$Base_Path"/Install\ macOS\ "$os_nice".app
    # File name and plist content manipulations
    mv "$pkgsdir/Install macOS $os_nice-$fqos.dmg" "$pkgsdir/$munki_name-$fqos.dmg"
    mv "$pkgsinfodir/$munki_name-$fqos-arm64" "$pkgsinfodir"/arm64/"$munki_name"-"$fqos".plist
    sed -i.tmp \
        -e "s/Installs macOS $os_nice, version $fqos/Installs macOS $os_nice $fqos/" \
        -e 's/installable_condition_disabled/installable_condition/g' \
        -e "s|$munki_path/Install macOS $os_nice-$fqos.dmg|$munki_path/$munki_name-$fqos.dmg|g" \
        "$pkgsinfodir"/arm64/"$munki_name"-"$fqos".plist
    if [[ $localization == "yes" ]]; then
        localized=$(awk '/<key>maximum_os_version<\/key>/ {print NR-1; exit}' "$pkgsinfodir"/arm64/"$munki_name"-"$fqos".plist)
        head -n "$localized" "$pkgsinfodir"/arm64/"$munki_name"-"$fqos".plist > "$pkgsinfodir"/arm64/"$munki_name"-"$fqos".plist.tmp
        cat "$Base_Path"/usr/localized_stage_os.txt >> "$pkgsinfodir"/arm64/"$munki_name"-"$fqos".plist.tmp
        awk -v localized="${localized}" 'NR > localized' "$pkgsinfodir"/arm64/"$munki_name"-"$fqos".plist >> "$pkgsinfodir"/arm64/"$munki_name"-"$fqos".plist.tmp
        sed "s/%version%/$fqos/g" "$pkgsinfodir"/arm64/"$munki_name"-"$fqos".plist.tmp > "$pkgsinfodir"/arm64/"$munki_name"-"$fqos".plist
    fi
    pre_inserts=$(awk '/<key>supported_architectures<\/key>/ {print NR-1; exit}' "$pkgsinfodir"/arm64/"$munki_name"-"$fqos".plist)
    head -n "$pre_inserts" "$pkgsinfodir"/arm64/"$munki_name"-"$fqos".plist > "$pkgsinfodir"/arm64/"$munki_name"-"$fqos".plist.tmp
    cat "$Template"/pre_inserts_arm64 >> "$pkgsinfodir"/arm64/"$munki_name"-"$fqos".plist.tmp
    awk -v pre_inserts="${pre_inserts}" 'NR > pre_inserts' "$pkgsinfodir"/arm64/"$munki_name"-"$fqos".plist >> "$pkgsinfodir"/arm64/"$munki_name"-"$fqos".plist.tmp
    mv "$pkgsinfodir"/arm64/"$munki_name"-"$fqos".plist.tmp "$pkgsinfodir"/arm64/"$munki_name"-"$fqos".plist
    chown "$Repo_uid_gid" "$pkgsdir/$munki_name-$fqos.dmg"
    chown -R "$Repo_uid_gid" "$pkgsinfodir"/arm64
}

preloader_arm() {
    sudo -u "$RepoOwner" munkiimport -n --installer-type copy_from_dmg --name="$munki_name"_arm \
    -c "$munki_catalog" --category="$munki_category" --developer=Apple \
    --displayname="macOS $os_nice preparation"  --description="Provisions macOS $os_nice $fqos for installation"  \
    --icon="$munki_name"_"$os_munki".png --minimum_munki_version=6.0.1 \
    --maximum_os_version="$os_maxi" --minimum_os_version="$os_mini" \
    --postinstall_script="$Template"/postinstall_script_installer \
    --arch=arm64 \
    --subdirectory="$munki_path" --unattended_install --unattended_uninstall \
    --pkgvers="$fqos" "$pkgsdir/$munki_name-$fqos.dmg"
    mv "$pkgsinfodir"/"$munki_name"_arm-"$fqos"-arm64.plist "$pkgsinfodir"/arm64/"$munki_name"_arm-"$fqos".plist
    # Retrieve installable_condition from munkiimport_macos and fill in
    if [[ $localization == "yes" ]]; then
        localized=$(awk '/<key>maximum_os_version<\/key>/ {print NR-1; exit}' "$pkgsinfodir"/arm64/"$munki_name"_arm-"$fqos".plist)
        head -n "$localized" "$pkgsinfodir"/arm64/"$munki_name"_arm-"$fqos".plist > "$pkgsinfodir"/arm64/"$munki_name"_arm-"$fqos".plist.tmp
        cat "$Base_Path"/usr/localized_arm.txt >> "$pkgsinfodir"/arm64/"$munki_name"_arm-"$fqos".plist.tmp
        awk -v localized="${localized}" 'NR > localized' "$pkgsinfodir"/arm64/"$munki_name"_arm-"$fqos".plist >> "$pkgsinfodir"/arm64/"$munki_name"_arm-"$fqos".plist.tmp
        sed "s/%version%/$fqos/g" "$pkgsinfodir"/arm64/"$munki_name"_arm-"$fqos".plist.tmp > "$pkgsinfodir"/arm64/"$munki_name"_arm-"$fqos".plist
    fi
    install_condition=$(grep '<string>board_id IN {' "$pkgsinfodir"/arm64/"$munki_name"-"$fqos".plist)
    install_hash=$(awk '/<key>installer_item_hash<\/key>/ {print NR-1; exit}' "$pkgsinfodir"/arm64/"$munki_name"_arm-"$fqos".plist)
    head -n "$install_hash" "$pkgsinfodir"/arm64/"$munki_name"_arm-"$fqos".plist > "$pkgsinfodir"/arm64/"$munki_name"_arm-"$fqos".plist.tmp
    echo '	<key>installable_condition</key>' >> "$pkgsinfodir"/arm64/"$munki_name"_arm-"$fqos".plist.tmp
    cat <<EOF >> "$pkgsinfodir"/arm64/"$munki_name"_arm-"$fqos".plist.tmp
$(echo "$install_condition")
EOF
    awk -v install_hash="${install_hash}" 'NR > install_hash' "$pkgsinfodir"/arm64/"$munki_name"_arm-"$fqos".plist >> "$pkgsinfodir"/arm64/"$munki_name"_arm-"$fqos".plist.tmp
    sed "s/%os_nice%/$os_nice/g" "$pkgsinfodir"/arm64/"$munki_name"_arm-"$fqos".plist.tmp > "$pkgsinfodir"/arm64/"$munki_name"_arm-"$fqos".plist
    rm "$pkgsinfodir"/arm64/"$munki_name"_arm-"$fqos".plist.tmp
}

deploy_macos() {
    sudo -u "$RepoOwner" munkiimport -n --installer-type copy_from_dmg --name="$deploy_name" \
    -c "$munki_catalog" --category="$munki_category" --developer=Apple --displayname="macOS $os_nice provisioning"  \
    --description="Downloads macOS $os_nice installer $fqos and places it in the Applications directory for installation at a later time."  \
    --icon="$munki_name"_"$os_munki".png --minimum_munki_version=6.0.1 \
    --maximum_os_version="$os_maxi" --minimum_os_version="$os_mini" \
    --postinstall_script="$Template"/postinstall_script_installer \
    --subdirectory="$munki_path" --unattended_install --unattended_uninstall \
    --pkgvers="$fqos" "$pkgsdir/$munki_name-$fqos.dmg"
    if [[ $localization == "yes" ]]; then
        localized=$(awk '/<key>maximum_os_version<\/key>/ {print NR-1; exit}' "$pkgsinfodir"/"$deploy_name"-"$fqos".plist)
        head -n "$localized" "$pkgsinfodir"/"$deploy_name"-"$fqos".plist > "$pkgsinfodir"/"$deploy_name"-"$fqos".plist.tmp
        cat "$Base_Path"/usr/localized_deploy.txt >> "$pkgsinfodir"/"$deploy_name"-"$fqos".plist.tmp
        awk -v localized="${localized}" 'NR > localized' "$pkgsinfodir"/"$deploy_name"-"$fqos".plist >> "$pkgsinfodir"/"$deploy_name"-"$fqos".plist.tmp
        sed "s/%version%/$fqos/g" "$pkgsinfodir"/"$deploy_name"-"$fqos".plist.tmp > "$pkgsinfodir"/"$deploy_name"-"$fqos".plist
    fi
    install_condition=$(grep '<string>board_id IN {' "$pkgsinfodir"/arm64/"$munki_name"-"$fqos".plist)
    install_hash=$(awk '/<key>installer_item_hash<\/key>/ {print NR-1; exit}' "$pkgsinfodir"/"$deploy_name"-"$fqos".plist)
    head -n "$install_hash" "$pkgsinfodir"/"$deploy_name"-"$fqos".plist > "$pkgsinfodir"/"$deploy_name"-"$fqos".plist.tmp
    echo '	<key>installable_condition</key>' >> "$pkgsinfodir"/"$deploy_name"-"$fqos".plist.tmp
    cat <<EOF >> "$pkgsinfodir"/"$deploy_name"-"$fqos".plist.tmp
$(echo "$install_condition")
EOF
    awk -v install_hash="${install_hash}" 'NR > install_hash' "$pkgsinfodir"/"$deploy_name"-"$fqos".plist >> "$pkgsinfodir"/"$deploy_name"-"$fqos".plist.tmp
    sed "s/%os_nice%/$os_nice/g" "$pkgsinfodir"/"$deploy_name"-"$fqos".plist.tmp > "$pkgsinfodir"/"$deploy_name"-"$fqos".plist
    rm "$pkgsinfodir"/"$deploy_name"-"$fqos".plist.tmp
}

munkiimport_startos() {
    munkiimport -n --installer-type startosinstall --name="$munki_name" \
    -c "$munki_catalog" --category="$munki_category" --developer=Apple \
    --displayname="macOS $os_nice" --description="Installs macOS $os_nice $fqos" \
    --icon="$munki_name"_"$os_munki".png --minimum_munki_version=5.1.0 \
    --maximum_os_version="$os_maxi" --minimum_os_version="$os_mini" \
    --arch=x86_64 --RestartAction=RequireRestart --repo-url=file://"$RepoPath" \
    --subdirectory="$munki_path" \
    --pkgvers="$fqos" "$Base_Path"/Install\ macOS\ "$os_nice".app
    rm "$pkgsdir/Install macOS $os_nice-$fqos.dmg"
    mv "$pkgsinfodir/$munki_name-$fqos-x86_64" "$pkgsinfodir"/x86_64/"$munki_name"-"$fqos".plist
    sed -i.tmp \
        -e "s/Installs macOS $os_nice, version $fqos/Installs macOS $os_nice $fqos/" \
        -e 's/installable_condition_disabled/installable_condition/g' \
        -e "s|$munki_path/Install macOS $os_nice-$fqos.dmg|$munki_path/$munki_name-$fqos.dmg|g" \
        "$pkgsinfodir"/x86_64/"$munki_name"-"$fqos".plist
    if [[ $localization == "yes" ]]; then
        localized=$(awk '/<key>maximum_os_version<\/key>/ {print NR-1; exit}' "$pkgsinfodir"/x86_64/"$munki_name"-"$fqos".plist)
        head -n "$localized" "$pkgsinfodir"/x86_64/"$munki_name"-"$fqos".plist > "$pkgsinfodir"/x86_64/"$munki_name"-"$fqos".plist.tmp
        cat "$Base_Path"/usr/localized_startos.txt >> "$pkgsinfodir"/x86_64/"$munki_name"-"$fqos".plist.tmp
        awk -v localized="${localized}" 'NR > localized' "$pkgsinfodir"/x86_64/"$munki_name"-"$fqos".plist >> "$pkgsinfodir"/x86_64/"$munki_name"-"$fqos".plist.tmp
        sed "s/%version%/$fqos/g" "$pkgsinfodir"/x86_64/"$munki_name"-"$fqos".plist.tmp > "$pkgsinfodir"/x86_64/"$munki_name"-"$fqos".plist
    fi
    pre_inserts=$(awk '/<key>supported_architectures<\/key>/ {print NR-1; exit}' "$pkgsinfodir"/x86_64/"$munki_name"-"$fqos".plist)
    head -n "$pre_inserts" "$pkgsinfodir"/x86_64/"$munki_name"-"$fqos".plist > "$pkgsinfodir"/x86_64/"$munki_name"-"$fqos".plist.tmp
    cat "$Template"/pre_inserts_x86_64 >> "$pkgsinfodir"/x86_64/"$munki_name"-"$fqos".plist.tmp
    awk -v pre_inserts="${pre_inserts}" 'NR > pre_inserts' "$pkgsinfodir"/x86_64/"$munki_name"-"$fqos".plist >> "$pkgsinfodir"/x86_64/"$munki_name"-"$fqos".plist.tmp
    mv "$pkgsinfodir"/x86_64/"$munki_name"-"$fqos".plist.tmp "$pkgsinfodir"/x86_64/"$munki_name"-"$fqos".plist
    chown -R "$Repo_uid_gid" "$pkgsinfodir"/x86_64
}

##################################
# Update checks                  #
##################################

# We want to check each major version seperately
mist list installer 14 --latest | grep GB > "$LogPath"/tmp_state_14.txt
mist list installer 13 --latest | grep GB > "$LogPath"/tmp_state_13.txt
mist list installer 12 --latest | grep GB > "$LogPath"/tmp_state_12.txt

# Remove color codes resulting from grep and clean up
rm_color_codes "$LogPath"/tmp_state_14.txt > "$LogPath"/current_state_14.txt
rm_color_codes "$LogPath"/tmp_state_13.txt > "$LogPath"/current_state_13.txt
rm_color_codes "$LogPath"/tmp_state_12.txt > "$LogPath"/current_state_12.txt
/bin/rm -f "$LogPath"/tmp_state_*.txt

# Compare the content with the previous state if present, ignoring last two columns (date and compatibliity)
if [ -f "$LogPath"/previous_state_14.txt ]; then
    if ! awk '{ for(i=2;i<=NF-4;i++) printf "%s ", $i; print "" }' "$LogPath"/current_state_14.txt | cmp -s - <(awk '{ for(i=2;i<=NF-4;i++) printf "%s ", $i; print "" }' "$LogPath"/previous_state_14.txt); then
        macos_14=$(extract_macos_version Sonoma "$LogPath"/current_state_14.txt)
    fi
fi

if [ -f "$LogPath"/previous_state_13.txt ]; then
    if ! awk '{ for(i=2;i<=NF-4;i++) printf "%s ", $i; print "" }' "$LogPath"/current_state_13.txt | cmp -s - <(awk '{ for(i=2;i<=NF-4;i++) printf "%s ", $i; print "" }' "$LogPath"/previous_state_13.txt); then
        macos_13=$(extract_macos_version Ventura "$LogPath"/current_state_13.txt)
    fi
fi

if [ -f "$LogPath"/previous_state_12.txt ]; then
    if ! awk '{ for(i=2;i<=NF-4;i++) printf "%s ", $i; print "" }' "$LogPath"/current_state_12.txt | cmp -s - <(awk '{ for(i=2;i<=NF-4;i++) printf "%s ", $i; print "" }' "$LogPath"/previous_state_12.txt); then
        macos_12=$(extract_macos_version Monterey "$LogPath"/current_state_12.txt)
    fi
fi

##################################
# Update routines                #
##################################

# Execute loops only if version has changed
if [ -n "$macos_14" ]; then
    fqos=$macos_14
    munki_catalog=$munki_catalog_14
    os_major="14"
    os_maxi="13.99"
    os_mini="10.13"
    os_munki="sonoma"
    os_nice="Sonoma"
    check_space
    rm_previous_files
    echo "Downloading installer for macOS $macos_14"
    download_macos
    munkiimport_stage_os
    preloader_arm
    deploy_macos
    munkiimport_startos
    rm -rf "$Base_Path"/Install\ macOS\ "$os_nice".app
    echo "Last update for macOS "$os_nice" ran on $(date)" >> "$LogPath"/changelog.txt
fi
if [ -n "$macos_13" ]; then
    fqos=$macos_13
    munki_catalog=$munki_catalog_13
    os_major="13"
    os_maxi="12.99"
    os_mini="10.12"
    os_munki="ventura"
    os_nice="Ventura"
    check_space
    rm_previous_files
    echo "Downloading installer for macOS $macos_13"
    download_macos
    munkiimport_stage_os
    preloader_arm
    deploy_macos
    munkiimport_startos
    rm -rf "$Base_Path"/Install\ macOS\ "$os_nice".app
    echo "Last update for macOS "$os_nice" ran on $(date)" >> "$LogPath"/changelog.txt
fi
if [ -n "$macos_12" ]; then
    fqos=$macos_12
    munki_catalog=$munki_catalog_12
    os_major="12"
    os_maxi="11.99"
    os_mini="10.9"
    os_munki="monterey"
    os_nice="Monterey"
    check_space
    rm_previous_files
    echo "Downloading installer for macOS $macos_12"
    download_macos
    munkiimport_stage_os
    preloader_arm
    deploy_macos
    munkiimport_startos
    rm -rf "$Base_Path"/Install\ macOS\ "$os_nice".app
    echo "Last update for macOS "$os_nice" ran on $(date)" >> "$LogPath"/changelog.txt
fi

##################################
# Cleanup at end, postinstall    #
##################################

# Overwrite previous state with new output
mv "$LogPath"/current_state_14.txt "$LogPath"/previous_state_14.txt
mv "$LogPath"/current_state_13.txt "$LogPath"/previous_state_13.txt
mv "$LogPath"/current_state_12.txt "$LogPath"/previous_state_12.txt

# Run user-specific postinstall if present and new package(s) were created
if [[ ( -n "$macos_12" || -n "$macos_13" || -n "$macos_14" ) && -f "$Base_Path"/usr/postinstall.sh ]]; then
    "$Base_Path"/usr/postinstall.sh
fi

# Run makecatalogs only if new package(s) were created
if [[ ( -n "$macos_12" || -n "$macos_13" || -n "$macos_14" ) ]]; then
    makecatalogs "$RepoPath" | grep 'warning'
fi

exit 0
